---
title: 파드와 노드 보기
weight: 10
description: |-
  쿠버네티스 애플리케이션 문제를 해결하는 방법 알아보기
  kubectl get, kubectl describe, kubectl logs 및
  kubectl exec.
---

<!DOCTYPE html>

<html lang="ko">

<body>

<div class="layout" id="top">

    <main class="content">

        <div class="row">

     <div class="col-md-8">
          <h3>목표</h3>
                <ul>
                    <li>쿠버네티스 파드에 대해 배운다.</li>
                    <li>쿠버네티스 노드에 대해 배운다.</li>
                    <li>배포된 애플리케이션의 문제를 해결한다.</li>
                </ul>
            </div>

            <div class="col-md-8">
                <h2>쿠버네티스 파드</h2>
                <p>모듈 <a href="/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">2</a>에서 배포를 생성했을 때, 쿠버네티스는 여러분의 애플리케이션 인스턴스에 <b>파드</b>를 생성했다. 파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커와 같은)들의 그룹을 나타내는 쿠버네티스의 추상적 개념으로 일부는 컨테이너에 대한 자원을 공유한다. 그 자원은 다음을 포함한다:</p>
                <ul>
                    <li>볼륨과 같은, 공유 스토리지</li>
                    <li>클러스터 IP 주소와 같은, 네트워킹</li>
                    <li>컨테이너 이미지 버전 또는 사용할 특정 포트와 같이, 각 컨테이너가 동작하는 방식에 대한 정보</li>
                </ul>
                <p>파드는 특유한 "로컬호스트" 애플리케이션 모형을 만들어. 상대적으로 밀접하게 결합되어진 상이한 애플리케이션 컨테이너들을 수용할 수 있다. 가령, 파드는 Node.js 앱과 더불어 Node.js 웹서버에 의해 발행되는 데이터를 공급하는 상이한 컨테이너를 함께 수용할 수 있다. 파드 내 컨테이너는 IP 주소, 그리고 포트 스페이스를 공유하고 항상 함께 위치하고 함께 스케쥴링 되고 동일 노드 상의 컨텍스트를 공유하면서 동작한다.</p>

            <p>파드는 쿠버네티스 플랫폼 상에서 최소 단위가 된다. 우리가 쿠버네티스에서 배포를 생성할 때, 그 배포는 컨테이너 내부에서 컨테이너와 함께 파드를 생성한다. 각 파드는 스케쥴 되어진 노드에게 묶여지게 된다. 그리고 (재구동 정책에 따라) 소멸되거나 삭제되기 전까지 그 노드에 유지된다. 노드에 실패가 발생할 경우, 클러스터 내에 가용한 다른 노드들을 대상으로 스케쥴되어진다.</p>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_lined">
                    <h3>요약:</h3>
                    <ul>
                        <li>파드</li>
                        <li>노드</li>
                        <li>Kubectl 주요 명령어</li>
                    </ul>
                </div>
                <div class="content__box content__box_fill">
                        <p><i>
                          파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커와 같은)들의 그룹이고 공유 스토리지 (볼륨), IP 주소 그리고 그것을 동작시키는 방식에 대한 정보를 포함하고 있다.
                        </i></p>
                </div>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2 style="color: #3771e3;">파드 개요</h2>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg"></p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2>노드</h2>
                <p>파드는 언제나 <b>노드</b> 상에서 동작한다. 노드는 쿠버네티스에서 워커 머신을 말하며 클러스터에 따라 가상 또는 물리 머신일 수 있다. 각 노드는 컨트롤 플레인에 의해 관리된다. 하나의 노드는 여러 개의 파드를 가질 수 있고, 쿠버네티스 컨트롤 플레인은 클러스터 내 노드를 통해서 파드에 대한 스케쥴링을 자동으로 처리한다. 컨트롤 플레인의 자동 스케줄링은 각 노드의 사용 가능한 리소스를 모두 고려한다.</p>

                <p>모든 쿠버네티스 노드는 최소한 다음과 같이 동작한다.</p>
                <ul>
                    <li>Kubelet은, 쿠버네티스 컨트롤 플레인과 노드 간 통신을 책임지는 프로세스이며, 하나의 머신 상에서 동작하는 파드와 컨테이너를 관리한다.</li>
                    <li>컨테이너 런타임(도커와 같은)은 레지스트리에서 컨테이너 이미지를 가져와 묶여 있는 것을 풀고 애플리케이션을 동작시키는 책임을 맡는다. </li>
                </ul>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill">
                    <p><i> 만약 컨테이너들이 밀접하게 결합되어 있고 디스크와 같은 자원을 공유해야 한다면 오직 하나의 단일 파드에 함께 스케쥴되어져야 한다. </i></p>
                </div>
            </div>
        </div>

        <br>

        <div class="row">
            <div class="col-md-8">
                <h2 style="color: #3771e3;">노드 개요</h2>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg"></p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2>kubectl로 문제해결하기</h2>
                <p>모듈 <a href="/ko/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">2</a>에서, Kubectl 커맨드-라인 인터페이스를 사용했다. 배포된 애플리케이션과 그 환경에 대한 정보를 얻기 위해 모듈3에서도 계속 그것을 사용할 것이다. 가장 보편적인 운용업무는 다음 kubectl 하위 명령어를 이용하여 처리할 수 있다:</p>
                <ul>
                    <li><tt><b>kubectl get</b></tt> - 자원을 나열한다</li>
                    <li><tt><b>kubectl describe</b></tt> - 자원에 대해 상세한 정보를 보여준다.</li>
                    <li><tt><b>kubectl logs</b></tt> - 파드 내 컨테이너의 로그들을 출력한다.</li>
                    <li><tt><b>kubectl exec</b></tt> - 파드 내 컨테이너에 대한 명령을 실행한다.</li>
                </ul>

                <p>언제 애플리케이션이 배포되었으며, 현재 상태가 어떠한지, 그것의 구성은 어떠한지 등을 보기 위해 이러한 명령을 이용할 수 있다.</p>

                <p>이제 클러스터 컴포넌트와 커맨드 라인에 대해 알아 보았으니, 애플리케이션을 조사해 보자.</p>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill">
                    <p><i> 노드는 쿠버네티스에 있어서 워커 머신이며 클러스터에 따라 VM 또는 물리 머신이 될 수 있다. 여러 개의 파드는 하나의 노드 위에서 동작할 수 있다.</i></p>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>애플리케이션 구성 확인</h3>
                <p>이전 시나리오에서 배포한 애플리케이션이 실행 중인지 확인해보자. <code>kubectl get</code> 명령을 사용하여 기존 파드를 찾아보자:</p>
                <p><b><code>kubectl get pods</code></b></p>
                <p>실행 중인 파드가 없으면, 몇 초간 기다린 후 파드를 다시 나열해보자. 하나의 파드가 실행 중이면 진행할 수 있다.</p>
                <p>다음으로, 해당 파드 내부에 어떤 컨테이너가 있고 해당 컨테이너를 빌드하는 데 사용되는 이미지를 보기 위해 <code>kubectl describe pods</code> 명령을 실행한다:</p>
                <p><b><code>kubectl describe pods</code></b></p>
                <p>파드의 컨테이너에 대한 세부 정보를 볼 수 있다: IP 주소, 사용된 포트 및 파드의 라이프사이클와 관련된 이벤트 목록</p>
                <p><tt>describe</tt> 하위 명령의 출력은 광범위하며 아직 설명하지 않은 일부 개념을 다루고 있지만, 걱정하지 말자, 이 부트캠프가 끝나면 익숙해질 것이다.</p>
                <p><em><strong>노트:</strong> <tt>describe</tt> 하위 명령을 사용하여 노드, 파드 및 디플로이먼트를 포함한 대부분의 쿠버네티스 프리미티브(primitives)에 대한 자세한 정보를 얻을 수 있다. describe 출력은 사람이 읽을 수 있도록 설계되었으며 스크립트로 작성할 수 없다.</em></p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>터미널에 앱 표시</h3>
                <p>파드는 격리된, 프라이빗 네트워크에서 실행되므로 - 디버깅하고 상호 작용할 수 있도록 
                파드에 대한 프록시 접근이 필요하다. 이를 위해, <code>kubectl proxy</code> 명령을 사용하여 <strong>두 번째 터미널</strong>에서 프록시를 실행한다. 새 터미널 창을 열고 새 터미널에서 다음을 실행하자:</p>
                <p><code><b>kubectl proxy</b></code></p>
                <p>이제 다시, 파드 이름을 가져오고 프록시를 통해 해당 파드를 직접 쿼리한다.
                파드 이름을 가져오고 <tt>POD_NAME</tt> 환경 변수에 저장하려면:</p>
                <p><code><b>export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"</b></code><br />
                <code><b>echo Name of the Pod: $POD_NAME</b></code></p>
                <p>애플리케이션의 출력을 보려면, <code>curl</code> 요청을 실행하자:</p>
                <p><code><b>curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</b></code></p>
                <p>URL은 파드의 API에 대한 경로이다.</p>
           </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>컨테이너 로그 보기</h3>
                <p>일반적으로 애플리케이션이 표준 출력으로 보내는 모든 항목은 파드 내의 컨테이너에 대한 로그가 된다. <code>kubectl logs</code> 명령을 사용하여 이 로그를 검색할 수 있다:</p>
                <p><code><b>kubectl logs "$POD_NAME"</b></code></p>
                <p><em><strong>노트:</strong> 파드 내부에 하나의 컨테이너만 있기 때문에, 컨테이너 이름을 지정할 필요가 없다.</em></p>
           </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>컨테이너에서 명령 실행</h3>
                <p>파드가 실행되면 컨테이너에서 직접 명령을 실행할 수 있다.
                이를 위해, <code>exec</code> 하위 명령을 사용하고 파드 이름을 매개변수로 사용한다. 환경 변수를 나열해보자:</p>
                <p><code><b>kubectl exec "$POD_NAME" -- env</b></code></p>
                <p>다시 말하지만, 파드에는 단일 컨테이너만 있으므로 컨테이너 자체의 이름을 생략할 수 있다.</p>
                <p>다음으로 파드의 컨테이너에서 bash 세션을 시작한다:</p>
                <p><code><b>kubectl exec -ti $POD_NAME -- bash</b></code></p>
                <p>이제 NodeJS 애플리케이션을 실행하는 컨테이너에 열린 콘솔이 있다. 앱의 소스 코드는 <tt>server.js</tt> 파일에 있다:</p>
                <p><code><b>cat server.js</b></code></p>
                <p><tt>curl</tt> 명령을 실행하여 애플리케이션이 실행 중인지 확인할 수 있다:</p>
                <p><code><b>curl http://localhost:8080</b></code></p>
                <p><em><strong>노트:</strong> 여기서는 NodeJS 파드 내부에서 명령을 실행했기 때문에 <tt>localhost</tt>를 사용했다. localhost:8080에 연결할 수 없는 경우, <code>kubectl exec</code> 명령을 실행했고 포드 내에서 명령을 실행하고 있는지 확인해보자.</em></p>
                <p>컨테이너 연결을 닫으려면, <code><b>exit</b></code>를 입력하자.</p>
           </div>
        </div>


      <div class="row">
          <p>
            준비가 됐다면, <a href="/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/" title="Using A Service To Expose Your App">서비스를 사용하여 앱 노출</a>로 이동하자.</p>
          </p>
      </div>


    </main>

</div>

</body>
</html>
